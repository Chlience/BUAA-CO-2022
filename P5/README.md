# P5 流水线 CPU

## 结构

![cpu.drawio.svg](https://github.com/Chlience/BUAA-CO/blob/main/P5/cpu.drawio.svg)

## 原则

* 所有变量采取驼峰命名法，变量名的完整组成为 `type+Module+Stage`
  * 比方说 `E` 阶段 `ALU` 的输入 `v1` 对应的变量名为 `v1AluE`


* 流水线寄存器仅仅保存 PC, Instruction 和计算得到的信息
  * 这也意味着能够直接从 Instruction 取得的信息将不会被保存


## 测试方案

指令集：`add`, `sub`, `ori`, `lw`, `sw`, `beq`, `lui`, `jal`, `jr`, `nop`

### 测试目标

* 单计算指令行为
* 单存取指令行为
* 单跳转指令行为
* 计算/存取指令数据冲突暂停转发行为
* 跳转指令与计算/存取指令数据冲突暂停转发行为

### 问题

* 为什么要使用流水寄存器转发而不是直接从计算部件输出转发

> 使用计算部件输出转发有个明显的优势：tNew 要小一个周期
> 
> 那为何不使用这样的方式呢？
> 
> 直接使用计算部件转发结果，那么数据需求者流水级（假设是 D 级）需要等数据提供者流水级（假设是 M 级）的稳定，才能开始自身组合逻辑的计算。这使得需求者的关键路径变成了提供者的关键路径和需求者的关键路径之和
> 
> 而流水寄存器因为位于流水级的开头，数据通路很短几乎可以忽略不计
> 
> 对于转发时多等待一个周期（流水寄存器转发）和关键路径翻倍使得总时间翻倍，前者的效率自然更高。（只看周期数的能不能爬啊）
